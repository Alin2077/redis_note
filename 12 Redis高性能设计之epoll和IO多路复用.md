## 多路复用要解决的问题
1. 并发多客户端连接，在多路复用之前最简单和典型的方案：<font color="red">同步阻塞网络IO模型</font>。这种模式的特点就是<font color="red">用一个进程来处理一个网络连接（一个用户请求）</font>
2. 进程在Linux上是一个开销不小的家伙。所以为了高效地对海量用户提供服务，<font color="red">必须要让一个进程能同时处理很多个tcp连接才行</font>。现在假设一个进程保持了10000条连接，那么如何发现哪条连接上数据可读了、哪条连接可写了？
3. 针对上面的问题，我们当然可以采用循环遍历的方式来发现IO事件，但这种方式太低级了。我们希望有一种更高效的机制，在很多连接中的某条由IO事件发生的时候直接快速把它找出来。其实这个事情Linux操作系统已经替我们都做好了，他就是我们熟知的IO多路复用机制。
4. <font color="red">这里的复用指的就是对进程的复用</font>
## 什么是多路IO复用？
1. IO：网络IO
2. 多路：多个客户端连接（连接就是套接字描述符，即socket或channel），指的是多条TCP连接
3. 复用：用一个进程来处理多条的连接，使用单进程就能够实现同时处理多个客户端的连接
## Redis单线程如何处理那么多并发客户端连接，为什么那么快？
1. Redis的IO多路复用
    * Redis利用epoll来实现IO多路复用，将连接信息和事件放入队列中，一次放到文件事件分派器，事件分派器将事件分发给事件处理器
    * Redis是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是<font color="red">
由于读写操作等待用户输入或输出都是阻塞的</font>，所以IO操作在一般情况下往往不能直接返回，这会导致某一文件的IO阻塞导致整个进程无法对其它客户提供服务，而IO多路复用就是为了解决这个问题而出现
    * 所谓IO多路复用机制，就是说通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作。这种机制的使用需要select、poll、epoll来配合。<font color="red">多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象上等待，无需阻塞等待所有连接。当某条连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理</font>
2. Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器。它的组成结构为4部分：
    1. 多个套接字
    2. IO多路复用程序
    3. 文件事件分派器
    4. 事件处理器
3. <font color="red">因为文件事件分派器队列的消费都是单线程，所以Redis才叫单线程模型</font>
## 参考《Redis设计与实现》
1. Redis基于Reactor模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）：
    * 文件事件处理器使用IO多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器
    * 当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件
2. 虽然文件事件处理器以单线程方式运行，但通过使用IO多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程方式运行地模块进行对接，这保持了Redis内部单线程设计地简单性
## Unix网络编程中的五种IO模型
1. Blocking IO - 阻塞IO
2. NoneBlocking IO - 非阻塞IO
3. IO multiplexing IO - IO多路复用
4. singal driven IO - 信号驱动IO
5. asynchronous IO - 异步IO
## 一些概念性理解
1. 同步
    * 调用者要一直等待调用结果的通知后才能进行后续的执行，现在就要，我可以等，等出结果为止
2. 异步
    * 指被调用方先返回应答让调用者先回去，然后再计算调用结果，计算完最终结果后再通知并返回给调用方
    * 异步调用要想获得结果一般通过回调
3. <font color="red">同步和异步的理解</font>
    * 同步、异步的讨论对象时被调用者（服务提供者），重点在于获得调用结果
4. 阻塞
    * 调用方一直再等待而且别的事情什么都不做，当前进/线程会被挂起，啥都不干
5. 非阻塞
    * 调用再发出去后，调用方先去忙别的事情，不会阻塞当前进/线程，而会立即返回
6. <font color="red">阻塞和非阻塞的理解</font>
    * 阻塞、非阻塞的讨论对象是调用者（服务请求者），重点在于等消息时候的行为
7. 总结
    * 同步阻塞 || 同步非阻塞 || 异步阻塞 || 异步非阻塞
## BIO
1. 简略过程
    * 用户端请求
    * 服务端接收请求（不一定一次接收完，因为请求数据可能很大，可能需要等待一段时间等待接收完）
    * 服务端准备数据（此时处于内核态）
    * 服务端将准备好的数据进行复制（此时处于用户态）
    * 用户端接收到数据
2. 问题
    * 客户端和服务端建立了连接，如果这个连接的客户端迟迟不发数据，进程就会一直堵塞菜read()方法上，这样其他客户端也不能进行连接也就是一次只能处理一个客户端，对客户很不友好
3. 如何解决问题？
    * 多线程。每个连接新建一个线程处理
## NIO
1. 简略过程
    * 用户端请求
    * 服务端接收请求
    * 服务端发现数据并没有准备好，返回error
    * 用户端再次发送请求
    * 服务端发现数据还在准备，返回error
    * 用户端又发送请求
    * 服务端发现数据准备好了，复制数据并返回
    * 用户端正确接收到数据
2. 一句话
    * <font color="red">用轮询代替阻塞</font>
3. 特点：
    * 在NIO模式中，一切都是非阻塞的：accept()方法是非阻塞的，如果没有客户端连接，就返回无连接标识；read()方法是非阻塞的，如果read()方法读取不到数据就返回空闲中标识，如果读取到数据时只阻塞read()方法读数据的时间
    * 在NIO模式中，只有一个线程：当一个客户端与服务端进行连接，这个socket就会加入到一个队列中，隔一段时间遍历一次，看这个socket的read()方法能否读到数据，<font color="red">这样一个线程就能处理多个客户端的连接和读取了</font>
4. 问题：
    * 连接数很多时，每次遍历花费的资源过多，而且每次都做了很多无用功
    * 整个遍历过程是在用户态进行的，用户态判断socket是否有数据还是调用内核的read()方法实现的，这就涉及到用户态和内核态的多次切换，开销很大
5. 优缺点：
    * 优点：不会阻塞在内核的等待数据过程，每次发起的IO请求会立即返回，不用阻塞等待，实时性较好
    * 缺点：轮询将会不断地询问内核，这将占用大量的CPU时间，系统资源利用率低，所以一般Web服务器不使用这种IO模型
    * 结论：让Linux内核搞定上述需求，我们将一批文件描述符通过一次系统调用传给内核由内核层去遍历，才能真正解决这个问题。<font color="red">IO多路复用应运而生，即将上述工作直接放进Linux内核，不再两态转换而是直接从内核获得结果，因为内核是非阻塞的</font>