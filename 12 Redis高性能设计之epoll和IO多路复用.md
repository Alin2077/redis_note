## 多路复用要解决的问题
1. 并发多客户端连接，在多路复用之前最简单和典型的方案：<font color="red">同步阻塞网络IO模型</font>。这种模式的特点就是<font color="red">用一个进程来处理一个网络连接（一个用户请求）</font>
2. 进程在Linux上是一个开销不小的家伙。所以为了高效地对海量用户提供服务，<font color="red">必须要让一个进程能同时处理很多个tcp连接才行</font>。现在假设一个进程保持了10000条连接，那么如何发现哪条连接上数据可读了、哪条连接可写了？
3. 针对上面的问题，我们当然可以采用循环遍历的方式来发现IO事件，但这种方式太低级了。我们希望有一种更高效的机制，在很多连接中的某条由IO事件发生的时候直接快速把它找出来。其实这个事情Linux操作系统已经替我们都做好了，他就是我们熟知的IO多路复用机制。
4. <font color="red">这里的复用指的就是对进程的复用</font>
## 什么是多路IO复用？
1. IO：网络IO
2. 多路：多个客户端连接（连接就是套接字描述符，即socket或channel），指的是多条TCP连接
3. 复用：用一个进程来处理多条的连接，使用单进程就能够实现同时处理多个客户端的连接
## Redis单线程如何处理那么多并发客户端连接，为什么那么快？
1. Redis的IO多路复用
    * Redis利用epoll来实现IO多路复用，将连接信息和事件放入队列中，一次放到文件事件分派器，事件分派器将事件分发给事件处理器
    * Redis是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是<font color="red">
由于读写操作等待用户输入或输出都是阻塞的</font>，所以IO操作在一般情况下往往不能直接返回，这会导致某一文件的IO阻塞导致整个进程无法对其它客户提供服务，而IO多路复用就是为了解决这个问题而出现
    * 所谓IO多路复用机制，就是说通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作。这种机制的使用需要select、poll、epoll来配合。<font color="red">多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象上等待，无需阻塞等待所有连接。当某条连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理</font>
2. Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器。它的组成结构为4部分：
    1. 多个套接字
    2. IO多路复用程序
    3. 文件事件分派器
    4. 事件处理器
3. <font color="red">因为文件事件分派器队列的消费都是单线程，所以Redis才叫单线程模型</font>
