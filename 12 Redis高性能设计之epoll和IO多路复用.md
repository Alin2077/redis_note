## 多路复用要解决的问题
1. 并发多客户端连接，在多路复用之前最简单和典型的方案：<font color="red">同步阻塞网络IO模型</font>。这种模式的特点就是<font color="red">用一个进程来处理一个网络连接（一个用户请求）</font>
2. 进程在Linux上是一个开销不小的家伙。所以为了高效地对海量用户提供服务，<font color="red">必须要让一个进程能同时处理很多个tcp连接才行</font>。现在假设一个进程保持了10000条连接，那么如何发现哪条连接上数据可读了、哪条连接可写了？
3. 针对上面的问题，我们当然可以采用循环遍历的方式来发现IO事件，但这种方式太低级了。我们希望有一种更高效的机制，在很多连接中的某条由IO事件发生的时候直接快速把它找出来。其实这个事情Linux操作系统已经替我们都做好了，他就是我们熟知的IO多路复用机制。
4. <font color="red">这里的复用指的就是对进程的复用</font>
## 什么是多路IO复用？
1. IO：网络IO
2. 多路：多个客户端连接（连接就是套接字描述符，即socket或channel），指的是多条TCP连接
3. 复用：用一个进程来处理多条的连接，使用单进程就能够实现同时处理多个客户端的连接
## Redis单线程如何处理那么多并发客户端连接，为什么那么快？
1. Redis的IO多路复用
    * Redis利用epoll来实现IO多路复用，将连接信息和事件放入队列中，一次放到文件事件分派器，事件分派器将事件分发给事件处理器
    * Redis是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是<font color="red">
由于读写操作等待用户输入或输出都是阻塞的</font>，所以IO操作在一般情况下往往不能直接返回，这会导致某一文件的IO阻塞导致整个进程无法对其它客户提供服务，而IO多路复用就是为了解决这个问题而出现
    * 所谓IO多路复用机制，就是说通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作。这种机制的使用需要select、poll、epoll来配合。<font color="red">多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象上等待，无需阻塞等待所有连接。当某条连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理</font>
2. Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器。它的组成结构为4部分：
    1. 多个套接字
    2. IO多路复用程序
    3. 文件事件分派器
    4. 事件处理器
3. <font color="red">因为文件事件分派器队列的消费都是单线程，所以Redis才叫单线程模型</font>
## 参考《Redis设计与实现》
1. Redis基于Reactor模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）：
    * 文件事件处理器使用IO多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器
    * 当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件
2. 虽然文件事件处理器以单线程方式运行，但通过使用IO多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程方式运行地模块进行对接，这保持了Redis内部单线程设计地简单性
## Unix网络编程中的五种IO模型
1. Blocking IO - 阻塞IO
2. NoneBlocking IO - 非阻塞IO
3. IO multiplexing IO - IO多路复用
4. singal driven IO - 信号驱动IO
5. asynchronous IO - 异步IO
## 一些概念性理解
1. 同步
    * 调用者要一直等待调用结果的通知后才能进行后续的执行，现在就要，我可以等，等出结果为止
2. 异步
    * 指被调用方先返回应答让调用者先回去，然后再计算调用结果，计算完最终结果后再通知并返回给调用方
    * 异步调用要想获得结果一般通过回调
3. <font color="red">同步和异步的理解</font>
    * 同步、异步的讨论对象时被调用者（服务提供者），重点在于获得调用结果
4. 阻塞
    * 调用方一直再等待而且别的事情什么都不做，当前进/线程会被挂起，啥都不干
5. 非阻塞
    * 调用再发出去后，调用方先去忙别的事情，不会阻塞当前进/线程，而会立即返回
6. <font color="red">阻塞和非阻塞的理解</font>
    * 阻塞、非阻塞的讨论对象是调用者（服务请求者），重点在于等消息时候的行为
7. 总结
    * 同步阻塞 || 同步非阻塞 || 异步阻塞 || 异步非阻塞
## BIO
1. 简略过程
    * 用户端请求
    * 服务端接收请求（不一定一次接收完，因为请求数据可能很大，可能需要等待一段时间等待接收完）
    * 服务端准备数据（此时处于内核态）
    * 服务端将准备好的数据进行复制（此时处于用户态）
    * 用户端接收到数据
2. 问题
    * 客户端和服务端建立了连接，如果这个连接的客户端迟迟不发数据，进程就会一直堵塞菜read()方法上，这样其他客户端也不能进行连接也就是一次只能处理一个客户端，对客户很不友好
3. 如何解决问题？
    * 多线程。每个连接新建一个线程处理
## NIO
1. 简略过程
    * 用户端请求
    * 服务端接收请求
    * 服务端发现数据并没有准备好，返回error
    * 用户端再次发送请求
    * 服务端发现数据还在准备，返回error
    * 用户端又发送请求
    * 服务端发现数据准备好了，复制数据并返回
    * 用户端正确接收到数据
2. 一句话
    * <font color="red">用轮询代替阻塞</font>
3. 特点：
    * 在NIO模式中，一切都是非阻塞的：accept()方法是非阻塞的，如果没有客户端连接，就返回无连接标识；read()方法是非阻塞的，如果read()方法读取不到数据就返回空闲中标识，如果读取到数据时只阻塞read()方法读数据的时间
    * 在NIO模式中，只有一个线程：当一个客户端与服务端进行连接，这个socket就会加入到一个队列中，隔一段时间遍历一次，看这个socket的read()方法能否读到数据，<font color="red">这样一个线程就能处理多个客户端的连接和读取了</font>
4. 问题：
    * 连接数很多时，每次遍历花费的资源过多，而且每次都做了很多无用功
    * 整个遍历过程是在用户态进行的，用户态判断socket是否有数据还是调用内核的read()方法实现的，这就涉及到用户态和内核态的多次切换，开销很大
5. 优缺点：
    * 优点：不会阻塞在内核的等待数据过程，每次发起的IO请求会立即返回，不用阻塞等待，实时性较好
    * 缺点：轮询将会不断地询问内核，这将占用大量的CPU时间，系统资源利用率低，所以一般Web服务器不使用这种IO模型
    * 结论：让Linux内核搞定上述需求，我们将一批文件描述符通过一次系统调用传给内核由内核层去遍历，才能真正解决这个问题。<font color="red">IO多路复用应运而生，即将上述工作直接放进Linux内核，不再两态转换而是直接从内核获得结果，因为内核是非阻塞的</font>
## IO Multiplexing（IO多路复用）
1. 是什么？
    * IO multiplexing 这里面的multiplexing指的其实是在单个线程通过记录跟踪每一个Sock(I/O流)的状态来同时管理多个I/O流，目的是尽量多的提高服务器的吞吐能力
    * 大家都用过nginx，nginx使用epoll接收请求，nginx会有很多链接进来，epoll会把他们都监视起来，然后像拨开关一样，谁有数据就拨向谁，然后调用相应的代码处理。redis类似
    * FileDescriptor（文件描述符）
        * 是计算机科学中的一个术语，是一个用于表达指向文件的引用的抽象化概念
        * 在形式上是一个非负整数
        * 实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表
        * 当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符
        * 在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开
        * 往往只适用于UNIX、Linux这样的操作系统
    * IO多路复用模型图
        [IO多路复用模型图](./IO多路复用.png)
    * IO多路复用概念
        * 就是我们所说的select、poll、epoll，也可称为event driven IO 事件驱动IO
        * 就是通过一种机制，一个进程可以监听多个描述符，一旦某个描述符（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作
        * 可以基于一个阻塞对象并同时在多个描述符上等待就绪，而不是使用多个线程（每一个文件描述符一个线程），这样可以大大节省系统资源。
        * IO多路复用的特点是<font color="red">通过一种机制一个进程能同时等待多个文件描述符而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select、poll、epoll等函数就可以返回</font>
2. Redis的IO多路复用
    * 流程图：
        [IO多路复用](./Redis的IO多路复用.png)
    * Reactor模式模型图：
        [Reactor模型](./Reactor模型.png)
        1. 指通过一个或多个输入同时传递给服务处理器的服务请求的事件驱动处理模式
        2. 服务端程序处理传入多路请求，并将它们同步分派给请求对应的处理线程，Reactor模式也叫Dispatcher模式
        3. <font color="red">IO多路复用统一监听事件，收到后分发（Dispatch给某线程），是编写高性能网络服务的必备技术</font>
3. select方法
    * 在linux系统中运行 man select 命令：
        ```c
        int select(int nfds,  //监控的文件描述符集合里最大的文件描述符加1
                     fd_set *readfds, //监控有读数到达文件描述符集合，传入传出参数
                     fd_set *writefds, //监控写数据到达文件描述符集合，传入传出参数
                     fd_set *exceptfds,  //监控异常发生到达文件描述符集合，传入传出参数
                     struct timeval *timeout //定时阻塞监控事件 1.NULL 永远等下去
                                            // 2.设置timeval，等待固定时间
                                            // 3.均设置为0，检查描述字后立即返回，轮询
                     );
        ```
    * 优点：select其实就是把NIO中用户态要遍历的fd数组（我们的每一个socket链接，安装进ArrayList里面的那个）拷贝到了内核态，让内核态来遍历，因为用户态判断socket是否有数据还是要调用内核态的，所以拷贝到内核态后，这样遍历判断的时候就不用一直用户态到内核态频繁切换了
    * 缺点：a.集合使用的bitmap最大1024位，即一个进程最多处理1024个客户端；b.rset不可被重用，每次socket有数据相应的位会被置空；c.文件描述符拷贝到内核态仍然有开销，如果数组很大，那么开销很惊人；
    d.select并没有通知用户态哪一个socket有数据，仍然需要O(n)的遍历
4. poll方法：
    * 在linux系统中运行 man poll 命令：
        ```c
         int poll(struct pollfd *fds, //
                nfds_t nfds, 
                int timeout);
         struct pollfd {
               int   fd;         //文件描述符
               short events;     //关系的事件，比如读事件或写事件
               short revents;    //如果该文件描述符有事件发生置为1
           };
        ```
    * poll的执行流程：
        1. 将五个fd从用户态拷贝到内核态
        2. poll为阻塞方法，执行poll方法，如果有数据会将fd对应的revents置为POLLIN
        3. poll方法返回
        4. 循环遍历，查找哪个fd被置为POLLIN了
        5. 将revents重置为0，便于复用
        6. 对置位的fd进行读取和处理
    * poll解决了select的什么问题？
        * 解决了bitmap大小限制
        * 解决了rset不可重用的情况
5. epoll方法：
    * 在linux系统中运行 man epoll 命令：    
        ```c
        int epoll_create(int size);

        int epoll_ctl(int epfd, //是epoll_create的返回值
                      int op,   //表示op操作，有EPOLL_CTL_ADD,EPOLL_CTL_DEL,EPOLL_CTL_MOD三种
                      int fd,   //需要监听的fd
                      struct epoll_event *event); //告诉内核要监听什么事件

        struct epoll_event{
            _unit32_t event; //定义的宏，用来表示读或写
            epoll_data_t data;
        }

        int epoll_wait(int epfd,struct epoll_event *events,int maxevents,int timeout);
        ```
    * 对上面方法的补充：
        * epoll_create方法的size参数并不限制epoll监听的描述符的最大个数，只是对初始分配内存的一个建议
        * epoll_wait方法的maxevents用来告知内核这个events有多大
    * epoll的执行流程：
        1. 当有数据的时候，会把相应的文件描述符“置位”，但是epoll没有revent标志位，所以并不是真正的置位。这时候会把有数据的文件描述符放到队首
        2. epoll会返回有数据的文件描述符的个数
        3. 根据epoll返回的个数读取前N个文件描述符即可
        4. 读取、处理
    * 优点：
        * 一个socket的生命周期中只有一次从用户态拷贝到内核态的过程，开销小
        * 使用event事件通知机制，每次socket中有数据会主动通知内核，并加入到就绪链表中，不需要遍历所有的socket
## 五种IO模型总结
1. 对比图：
    [对比](./总结.png)
